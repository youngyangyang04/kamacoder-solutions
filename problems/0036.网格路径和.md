# 36. 网格路径和

[题目链接](https://kamacoder.com/problem.php?id=1036)

## C++

```c++
/*
 * 比较简单的一个动态规划，leetcode类似题目很多，想要练习可以去做做
 * 难点主要在处理输入
 */
#include <bits/stdc++.h>
using namespace std;
void solve() {
    string input;
    cin >> input;
    // 移除首尾的括号
    input = input.substr(1, input.length() - 2);

    vector<vector<int>> result;
    vector<int> row;
    istringstream ss(input);
    char ch;
    while (ss >> ch) {
        if (ch == '[') {
            row.clear();
        } else if (ch == ']') {
            result.push_back(row);
        } else if (isdigit(ch) || ch == '-') {
            ss.putback(ch);
            int num;
            ss >> num;
            row.push_back(num);
        }
    }
    int m = result.size(), n = result[0].size();
    int f[m][n];
    memset(f, 0, sizeof(f));
    f[0][0] = result[0][0];
    for (int i = 1; i < m; ++i) {
        f[i][0] = f[i - 1][0] + result[i][0];
    }
    for (int i = 1; i < n; ++i) {
        f[0][i] = f[0][i - 1] + result[0][i];
    }
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]) + result[i][j];
        }
    }
    cout << f[m - 1][n - 1] << endl;
}

int main() {
    solve();
    return 0;
}
```



## Java

```java
/**
 * 思路：动态规划
 * 当解决网格中的路径问题的时候，我们需要考虑如何在每
 * 个格子上做出最优的选择，以确保获取最大的路径和。
 * 
 * 对于这个问题，通过创建一个和网格一样大小的二维数组 dp,
 * 其中，dp[i][j]代表了从左上角到达格子(i, j)位置的
 * 最大路径和。
 * 
 * 其次，对二维数组的第一行和第一列进行初始化，因为
 * 这两个方向上只有一种移动方式，即一直向右或一直向下。
 * 不受其他方向的影响。
 * 
 * 接下来，从第二行、第二列开始，逐步填充数组 dp，对于
 * 位置（i, j)，我们可以从该位置的上方（i - 1, j）和
 * 该位置的左方（i, j - 1）移动到当前位置。只需要选择
 * 这两个方向中较大的那个路径和，就可到达当前位置的最大路径和。
 */
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String arrayString = scanner.next();
        int[][] grid = parse2dArray(arrayString);
        System.out.println(maxPathSum(grid));
    }
    public static int maxPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];

        // 初始化
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }

        // 填充数组
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                // 选择较大的路径和
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }

    // 将字符串解析为二维数组
    public static int[][] parse2dArray(String arrayString) {
        String[] rowStrings = arrayString.substring(2, arrayString.length() - 2).split("],");
        // "[[1,2,3],[2,3,4],[3,4,5]]" -> "[1,2,3", "[2,3,4", "[3,4,5]"
        int rows = rowStrings.length;
        int cols = rowStrings[0].split(",").length;
        int[][] digital2dArray = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            String rowString = rowStrings[i].replaceAll("\\[|\\]", ""); // 去除所有中括号
            // "[1,2,3" -> "1,2,3"
            // "[2,3,4" -> "2,3,4"
            // "[3,4,5]" -> "3,4,5"
            String[] elements = rowString.split(",");
            // "1,2,3" -> 1 2 3
            // "2,3,4" -> 2 3 4
            // "3,4,5" -> 3 4 5
            for (int j = 0; j < cols; j++) {
                digital2dArray[i][j] = Integer.parseInt(elements[j]);
            }
        }
        return digital2dArray;
    }
}
```

## Python

## Go

## JS

## C